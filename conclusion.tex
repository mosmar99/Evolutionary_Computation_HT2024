\section{Conclusion}
\subsection{Recap}
The N-Queens problem is a well known combinatorial problem, a problem in which the aim is to place N number of queens on a N times N board in such a way that none are attacking each other. This is a very well documented problem \& provided a great way for experimenting and implementing different evolutionary computing algorithms.
\\\\
We started off with some simple code we found in the course material. We began off by modularizing the code in order to easily add and change the different strategies used, we for instance tested different recombinatorial, mutation \& initialization strategies. We also worked with parameter tuning in changing the population sizes, max evaluations count, mutation \& recombination rates. Towards the end we started experimenting with both static and dynamic genocide.
\subsection{Reflections on results}
\subsubsection{Strategies \& parameter tuning}
As mentioned in the \textbf{\textit{5. Results \& Analysis}} finding the most optimal strategies was easier than the parameters, we had clearer answers and the patterns were easier to analyze. We found the most optimal setup to be:
\begin{verbatim}
    optimal_setup = {   'GENOME_SIZE': 8,
                        'POPULATION_SIZE': 116, 
                        'MAX_FITNESS_EVALUATIONS': 10000,
                        'NUM_OFFSPRING_RATE': 0.543, 
                        'RECOMBINATION_RATE': 0.716, 
                        'MUTATION_RATE': 0.065, 
                        'TOURNAMENT_GROUP_SIZE': 0.515, 
                        'MAX_STAGNANT_GENERATIONS': 3,
                        'TOLERANCE': 1e-2,
                        'GENOCIDE_PERC': 0.3,
                        'initialization_strategy': 'random', 
                        'parent_selection_strategy': 'tournament', 
                        'fitness_strategy':           'conflict_based',
                        'recombination_strategy': 'pmx_dp_rm', 
                        'mutation_strategy': 'duplicate_replacement', 
                        'survival_selection_strategy': 'prob_survival',
                        'termination_strategy': 'evaluation_count',
                        'visualization_strategy': 'terminal',
                    }
\end{verbatim}
You can find a more in depth explanation \& analysis of the different parameters \& strategies in the
\textbf{\textit{5. Results \& Analysis}} part. However using the above settings we are able to fast \& consistently find a solution for the N-Queens problem in the least amount of evaluations possible. Whilst bench-marking the different strategies \& parameters against each other we defined one setup being better than the other by the amount of evaluations it took on average to find a solution, the lower the better.
\subsection{Tips on continuing}
While our results demonstrate an efficient setup for solving the N-Queens problem, there is room for improvement, especially in the areas of scalability and parameter tuning. Below, we outline some key areas for further exploration
\subsubsection{Parameter tuning}
A Deeper exploration of the parameters, as mentioned above we worked with for instance tweaking the mutation, population size, max evaluations and more. However this could be expanded upon by running larger tests for in theory better results. The patterns generated by the parameters may be to complex to analyze in two dimensions, this is something one could look into as well. One could use tools like grid search or Bayesian optimization to find parameters \& tools to examine the higher dimensions like PCA (Principal Component Analysis)
\subsubsection{Scalability analysis}
More investigation into how the algorithm scales with extreme sizes of N, it is known that genetic algorithms for this problem out-class backtracking algorithms for larger sizes of N, however testing and tweaking the different strategies for extremer sizes of N might be interesting
\subsubsection{Threading, parallelism \& optimizations}
We did use threading in combination with our parameter tuning to speed the entire process up, however if one where want to for instance explore the point mentioned above experimenting with distributed computing approaches will probably be needed, or simply as a challenge to find a solution as fast as possible
\subsection{Closing Thoughts}
This study and report have demonstrated the effectiveness of evolutionary algorithms both generally and for this problem specifically. It has opened up opportunities for further exploration in areas like parameter tuning, scalability and parallelism. The algorithm can likely be fine tuned in these areas to handle even larger instances efficiently, continuing to outperform traditional methods like back-tracking in time.